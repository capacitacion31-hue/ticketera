<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MessageService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Ticketero API</a> &gt; <a href="index.source.html" class="el_package">com.example.ticketero.service</a> &gt; <span class="el_source">MessageService.java</span></div><h1>MessageService.java</h1><pre class="source lang-java linenums">package com.example.ticketero.service;

import com.example.ticketero.model.entity.Mensaje;
import com.example.ticketero.model.entity.Ticket;
import com.example.ticketero.model.enums.EstadoEnvio;
import com.example.ticketero.model.enums.MessageTemplate;
import com.example.ticketero.repository.MensajeRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
<span class="fc" id="L20">@Slf4j</span>
@Transactional(readOnly = true)
public class MessageService {

    private final MensajeRepository mensajeRepository;
    private final AuditService auditService;

    @Transactional
    public void scheduleTicketCreatedMessage(Ticket ticket) {
<span class="fc bfc" id="L29" title="All 2 branches covered.">        if (ticket.getTelefono() == null) {</span>
<span class="fc" id="L30">            log.debug(&quot;No phone number for ticket {}, skipping message&quot;, ticket.getNumero());</span>
<span class="fc" id="L31">            return;</span>
        }

<span class="fc" id="L34">        Mensaje mensaje = Mensaje.builder()</span>
<span class="fc" id="L35">            .ticket(ticket)</span>
<span class="fc" id="L36">            .plantilla(MessageTemplate.TOTEM_TICKET_CREADO)</span>
<span class="fc" id="L37">            .estadoEnvio(EstadoEnvio.PENDIENTE)</span>
<span class="fc" id="L38">            .fechaProgramada(LocalDateTime.now())</span>
<span class="fc" id="L39">            .intentos(0)</span>
<span class="fc" id="L40">            .build();</span>

<span class="fc" id="L42">        mensajeRepository.save(mensaje);</span>
<span class="fc" id="L43">        log.info(&quot;Scheduled TICKET_CREADO message for ticket {}&quot;, ticket.getNumero());</span>
<span class="fc" id="L44">    }</span>

    @Transactional
    public void scheduleProximoTurnoMessage(Ticket ticket) {
<span class="fc bfc" id="L48" title="All 4 branches covered.">        if (ticket.getTelefono() == null || ticket.getPositionInQueue() &gt; 3) {</span>
<span class="fc" id="L49">            return;</span>
        }

<span class="fc" id="L52">        Mensaje mensaje = Mensaje.builder()</span>
<span class="fc" id="L53">            .ticket(ticket)</span>
<span class="fc" id="L54">            .plantilla(MessageTemplate.TOTEM_PROXIMO_TURNO)</span>
<span class="fc" id="L55">            .estadoEnvio(EstadoEnvio.PENDIENTE)</span>
<span class="fc" id="L56">            .fechaProgramada(LocalDateTime.now())</span>
<span class="fc" id="L57">            .intentos(0)</span>
<span class="fc" id="L58">            .build();</span>

<span class="fc" id="L60">        mensajeRepository.save(mensaje);</span>
<span class="fc" id="L61">        log.info(&quot;Scheduled PROXIMO_TURNO message for ticket {}&quot;, ticket.getNumero());</span>
<span class="fc" id="L62">    }</span>

    @Transactional
    public void scheduleEsTuTurnoMessage(Ticket ticket) {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (ticket.getTelefono() == null) {</span>
<span class="fc" id="L67">            return;</span>
        }

<span class="fc" id="L70">        Mensaje mensaje = Mensaje.builder()</span>
<span class="fc" id="L71">            .ticket(ticket)</span>
<span class="fc" id="L72">            .plantilla(MessageTemplate.TOTEM_ES_TU_TURNO)</span>
<span class="fc" id="L73">            .estadoEnvio(EstadoEnvio.PENDIENTE)</span>
<span class="fc" id="L74">            .fechaProgramada(LocalDateTime.now())</span>
<span class="fc" id="L75">            .intentos(0)</span>
<span class="fc" id="L76">            .build();</span>

<span class="fc" id="L78">        mensajeRepository.save(mensaje);</span>
<span class="fc" id="L79">        log.info(&quot;Scheduled ES_TU_TURNO message for ticket {}&quot;, ticket.getNumero());</span>
<span class="fc" id="L80">    }</span>

    @Scheduled(fixedDelay = 5000) // Cada 5 segundos
    @Transactional
    public void processPendingMessages() {
<span class="fc" id="L85">        List&lt;Mensaje&gt; pendingMessages = mensajeRepository.findPendingMessages(LocalDateTime.now());</span>
        
<span class="fc bfc" id="L87" title="All 2 branches covered.">        for (Mensaje mensaje : pendingMessages) {</span>
<span class="fc" id="L88">            sendMessage(mensaje);</span>
<span class="fc" id="L89">        }</span>
<span class="fc" id="L90">    }</span>

    @Scheduled(fixedDelay = 30000) // Cada 30 segundos
    @Transactional
    public void processRetryMessages() {
<span class="fc" id="L95">        List&lt;Mensaje&gt; retryMessages = mensajeRepository.findRetryableMessages(LocalDateTime.now());</span>
        
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (Mensaje mensaje : retryMessages) {</span>
<span class="fc" id="L98">            sendMessage(mensaje);</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">    }</span>

    @Async
    @Transactional
    public void sendMessage(Mensaje mensaje) {
        try {
<span class="fc" id="L106">            mensaje.setIntentos(mensaje.getIntentos() + 1);</span>
            
            // Simular env√≠o a Telegram API
<span class="fc" id="L109">            String messageText = buildMessageText(mensaje);</span>
<span class="fc" id="L110">            String telegramMessageId = sendToTelegramAPI(mensaje.getTicket().getTelefono(), messageText);</span>
            
            // √âxito
<span class="fc" id="L113">            mensaje.setEstadoEnvio(EstadoEnvio.ENVIADO);</span>
<span class="fc" id="L114">            mensaje.setFechaEnvio(LocalDateTime.now());</span>
<span class="fc" id="L115">            mensaje.setTelegramMessageId(telegramMessageId);</span>
            
<span class="fc" id="L117">            log.info(&quot;Message sent successfully: {} for ticket {}&quot;, </span>
<span class="fc" id="L118">                mensaje.getPlantilla(), mensaje.getTicket().getNumero());</span>
                
<span class="nc" id="L120">        } catch (Exception e) {</span>
<span class="nc" id="L121">            log.error(&quot;Failed to send message for ticket {}: {}&quot;, </span>
<span class="nc" id="L122">                mensaje.getTicket().getNumero(), e.getMessage());</span>
            
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (mensaje.getIntentos() &gt;= 4) {</span>
<span class="nc" id="L125">                mensaje.setEstadoEnvio(EstadoEnvio.FALLIDO);</span>
<span class="nc" id="L126">                log.error(&quot;Message failed permanently after 4 attempts: {}&quot;, mensaje.getId());</span>
            } else {
                // Programar reintento con backoff exponencial
<span class="nc" id="L129">                int delayMinutes = calculateBackoffDelay(mensaje.getIntentos());</span>
<span class="nc" id="L130">                mensaje.setFechaProgramada(LocalDateTime.now().plusMinutes(delayMinutes));</span>
<span class="nc" id="L131">                log.info(&quot;Scheduled retry #{} in {} minutes for message {}&quot;, </span>
<span class="nc" id="L132">                    mensaje.getIntentos() + 1, delayMinutes, mensaje.getId());</span>
            }
<span class="fc" id="L134">        }</span>
        
<span class="fc" id="L136">        mensajeRepository.save(mensaje);</span>
<span class="fc" id="L137">    }</span>

    private String buildMessageText(Mensaje mensaje) {
<span class="fc" id="L140">        Ticket ticket = mensaje.getTicket();</span>
        
<span class="fc bfc" id="L142" title="All 3 branches covered.">        return switch (mensaje.getPlantilla()) {</span>
<span class="fc" id="L143">            case TOTEM_TICKET_CREADO -&gt; String.format(&quot;&quot;&quot;</span>
                ‚úÖ &lt;b&gt;Ticket Creado&lt;/b&gt;
                Tu n√∫mero de turno: &lt;b&gt;%s&lt;/b&gt;
                Posici√≥n en cola: &lt;b&gt;#%d&lt;/b&gt;
                Tiempo estimado: &lt;b&gt;%d minutos&lt;/b&gt;
                Te notificaremos cuando est√©s pr√≥ximo.
<span class="fc" id="L149">                &quot;&quot;&quot;, ticket.getNumero(), ticket.getPositionInQueue(), ticket.getEstimatedWaitMinutes());</span>
                
<span class="fc" id="L151">            case TOTEM_PROXIMO_TURNO -&gt; String.format(&quot;&quot;&quot;</span>
                ‚è∞ &lt;b&gt;¬°Pronto ser√° tu turno!&lt;/b&gt;
                Turno: &lt;b&gt;%s&lt;/b&gt;
                Faltan aproximadamente 3 turnos.
                Por favor, ac√©rcate a la sucursal.
<span class="fc" id="L156">                &quot;&quot;&quot;, ticket.getNumero());</span>
                
<span class="fc" id="L158">            case TOTEM_ES_TU_TURNO -&gt; String.format(&quot;&quot;&quot;</span>
                üîî &lt;b&gt;¬°ES TU TURNO %s!&lt;/b&gt;
                Dir√≠gete al m√≥dulo: &lt;b&gt;%d&lt;/b&gt;
                Asesor: &lt;b&gt;%s&lt;/b&gt;
<span class="fc" id="L162">                &quot;&quot;&quot;, ticket.getNumero(), </span>
<span class="fc" id="L163">                ticket.getAssignedModuleNumber(),</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                ticket.getAssignedAdvisor() != null ? ticket.getAssignedAdvisor().getName() : &quot;N/A&quot;);</span>
        };
    }

    private String sendToTelegramAPI(String phoneNumber, String messageText) {
        // Simulaci√≥n de env√≠o a Telegram API
        // En producci√≥n: HTTP call a https://api.telegram.org/bot{token}/sendMessage
<span class="fc" id="L171">        log.debug(&quot;Sending to {}: {}&quot;, phoneNumber, messageText);</span>
<span class="fc" id="L172">        return &quot;msg_&quot; + System.currentTimeMillis();</span>
    }

    private int calculateBackoffDelay(int attemptNumber) {
        // RN-008: Backoff exponencial (30s, 60s, 120s)
<span class="nc bnc" id="L177" title="All 5 branches missed.">        return switch (attemptNumber) {</span>
<span class="nc" id="L178">            case 1 -&gt; 0;   // Inmediato</span>
<span class="nc" id="L179">            case 2 -&gt; 1;   // 30 segundos (convertido a minutos para simplificar)</span>
<span class="nc" id="L180">            case 3 -&gt; 1;   // 60 segundos</span>
<span class="nc" id="L181">            case 4 -&gt; 2;   // 120 segundos</span>
<span class="nc" id="L182">            default -&gt; 5;</span>
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>